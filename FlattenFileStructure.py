import os
import shutil
from time import time
from collections import defaultdict

DOT = "."


def flatten_directory(current_dir: str, destination_dir: str, file_count: defaultdict) -> None:
    """
    Recursively flatten file structure.
    When there's a file with duplicate name (take file extension into account),
    rename file to <originalName>__<dupCount>.<fileExtension>

    current_dir: reflect the recursive tree path
    destination_dir: stays the same as the destination
    """
    for file in os.listdir(current_dir):
        item_path = os.path.join(current_dir, file)
        if os.path.isdir(item_path):  # found dir, keep going down recursion tree
            flatten_directory(item_path, destination_dir, file_count)
        else:  # leaf node
            new_file_name = handle_duplicate_file_name(file, file_count)
            destination_path = os.path.join(destination_dir, new_file_name)
            shutil.copy(item_path, destination_path)
            # print(f"Copied {item_path} to {destination_path}")  # TODO: comment out this line after debug


def handle_duplicate_file_name(file, file_count) -> str:
    """
    Checks for duplicate file name (detect dup using the original file name) and
    when there's a file with duplicate name (take file extension into account),
    rename file to <originalName>__<dupCount>.<fileExtension>

    There are quite a few possibilities generated by Google Photos:
    1. Photos themselves have name like blah.jpg, if duplicated, it will be transformed to blah__1.jpg
       1a. There can be cases where dot is inside the name, e.g. bl.ah.jpg, it will be transformed to bl__1.ah.jpg to
       always append to the first segment (split by dot).
    2. Json metadata files have name like blah.jpg.json, if duplicated, it needs to be transformed to blah__1.jpg.json
       (not blah.jpg__1.json) to maintain the mapping using names.
       2a. Similar to 1a, bl.ah.jpg.json will be transformed to bl__1.ah.jpg.json to match the photo counterpart.

    :param file: the file which we check for duplicate
    :param file_count: map that maintains count of file name occurrences
    :return: a new name <originalName>__<dupCount>.<fileExtension> to avoid duplicates.
    """
    new_file_name = file
    # if os.path.exists(os.path.join(destination_dir, new_file_name)):  # duplicate name found
    if file in file_count:  # duplicate name found
        updated_count = file_count.get(file, 0) + 1
        file_count[file] = updated_count

        base_name, extension = os.path.splitext(file)
        # append the count to first segment of dot-separated string
        dot_separated_list = base_name.split(DOT)
        dot_separated_list[0] = f"{dot_separated_list[0]}__{updated_count}"
        file_name_with_count = DOT.join(dot_separated_list)  # for not dot separated string, join will be no-op
        new_file_name = f"{file_name_with_count}{extension}"
        print(f"MINOR: found duplicate file --- {file}, renamed to {new_file_name}")
    else:
        file_count[file] = 0  # count starts from 0, first duplicate will have __1.ext
    return new_file_name


def main() -> None:
    source_dir = input("Enter source directory path: ")
    destination_dir = input("Enter destination directory path: ")
    start_time = time()

    if not os.path.exists(destination_dir):
        os.makedirs(destination_dir)

    file_count = defaultdict(int)  # keeps track of count of <fileName>.<fileExt> occurrences to rename duplicates
    flatten_directory(source_dir, destination_dir, file_count)

    time_in_seconds = time() - start_time
    time_in_minutes = time_in_seconds / 60
    print(f"Flattening and copying complete. Total time taken: {time_in_seconds} seconds or {time_in_minutes} minutes")


if __name__ == "__main__":
    main()
